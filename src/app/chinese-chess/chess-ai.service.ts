import { Injectable } from '@angular/core';
import { ChessPiece, PieceType, PlayerColor, Position, GameState } from './chess-piece.interface';
import { ChessGameService } from './chess-game.service';

interface MoveEvaluation {
  from: Position;
  to: Position;
  score: number;
  capturedPiece?: ChessPiece;
}

@Injectable({
  providedIn: 'root',
})
export class ChessAIService {
  // Á∞°ÂñÆÁöÑÈÅäÊà≤Ê®°ÂºèÂ≠∏ÁøíÂ≠òÂÑ≤
  private gameMemory: {
    playerMoves: Array<{ from: Position; to: Position; evaluation: number }>;
    playerPreferences: {
      aggressive: number;
      defensive: number;
      positional: number;
    };
    gameCount: number;
  } = {
    playerMoves: [],
    playerPreferences: {
      aggressive: 0.5,
      defensive: 0.5,
      positional: 0.5
    },
    gameCount: 0
  };

  constructor(private chessGameService: ChessGameService) {
    // ÂòóË©¶ÂæûlocalStorageËºâÂÖ•Â≠∏ÁøíÊï∏Êìö
    this.loadGameMemory();
  }

  // AIÊÄùËÄÉÊ∑±Â∫¶
  private readonly MAX_DEPTH = 3;

  // ÈñãÂ±ÄÂ∫´ - Â∏∏Ë¶ãË±°Ê£ãÈñãÂ±ÄËµ∞Ê≥ï
  private readonly OPENING_BOOK = [
    // Áï∂È†≠ÁÇÆÈñãÂ±Ä
    [
      { from: { x: 7, y: 2 }, to: { x: 7, y: 4 }, name: '‰∏ÉË∑ØÁÇÆÈñãÂ±Ä' },
      { from: { x: 1, y: 2 }, to: { x: 1, y: 4 }, name: '‰∫åË∑ØÁÇÆÈñãÂ±Ä' },
    ],
    // È£õË±°Â±Ä
    [
      { from: { x: 2, y: 0 }, to: { x: 4, y: 2 }, name: 'Ëµ∑È£õË±°' },
      { from: { x: 6, y: 0 }, to: { x: 4, y: 2 }, name: 'Ëµ∑È£õË±°' },
    ],
    // ÈÄ≤È¶¨ÈñãÂ±Ä
    [
      { from: { x: 1, y: 0 }, to: { x: 2, y: 2 }, name: 'Â∑¶È¶¨Âá∫Âãï' },
      { from: { x: 7, y: 0 }, to: { x: 6, y: 2 }, name: 'Âè≥È¶¨Âá∫Âãï' },
    ],
    // Â£´ËßíÁÇÆÈñãÂ±Ä
    [
      { from: { x: 1, y: 2 }, to: { x: 4, y: 2 }, name: 'Â£´ËßíÁÇÆ' },
      { from: { x: 7, y: 2 }, to: { x: 4, y: 2 }, name: 'Â£´ËßíÁÇÆ' },
    ]
  ];

  // Â∏∏Ë¶ã‰∏≠Â±ÄÊ®°Âºè
  private readonly PATTERNS = {
    // ÊîªÊìäÊ®°Âºè
    ATTACK_PATTERNS: [
      'ÈõôËªäÊ≠∏ÈÇä', 'ÁÇÆÊâì‰∏≠ÂÖµ', 'È¶¨ÂæåÁÇÆ', 'ÈõôÁÇÆÈÅéÊ≤≥'
    ],
    // Èò≤ÂÆàÊ®°Âºè
    DEFENSE_PATTERNS: [
      'Â±èÈ¢®È¶¨', 'ÂèçÂÆÆÈ¶¨', 'ÈæúËÉåÁÇÆ', 'ÈêµÊªëËªä'
    ]
  };

  // AIÂÄãÊÄßÂèÉÊï∏
  private readonly AI_PERSONALITY = {
    AGGRESSIVE: 0.8,    // ÊîªÊìäÊÄß
    CAUTIOUS: 0.6,      // Ë¨πÊÖéÊÄß
    CREATIVE: 0.7,      // ÂâµÈÄ†ÊÄß
    CONSISTENCY: 0.5    // ‰∏ÄËá¥ÊÄßÔºà‰Ωé‰∏ÄËá¥ÊÄß = Êõ¥Â§öËÆäÂåñÔºâ
  };

  // Ê£ãÂ≠êÂÉπÂÄºË°®
  private readonly PIECE_VALUES = {
    [PieceType.KING]: 10000,
    [PieceType.ROOK]: 500,
    [PieceType.CANNON]: 450,
    [PieceType.HORSE]: 400,
    [PieceType.ELEPHANT]: 200,
    [PieceType.ADVISOR]: 200,
    [PieceType.SOLDIER]: 100,
  };

  makeAIMove(gameState: GameState): { from: Position; to: Position } | null {
    console.log('ü§ñ AIÈñãÂßãÂàÜÊûêÊ£ãÂ±Ä...');

    const allMoves = this.getAllPossibleMoves(gameState, PlayerColor.BLACK);
    console.log(`ü§ñ ÊâæÂà∞ ${allMoves.length} ÂÄãÂèØËÉΩÁßªÂãï`);

    // Â¶ÇÊûúÊ≤íÊúâÂèØËÉΩÁöÑÁßªÂãïÔºåAIÊäïÈôç
    if (allMoves.length === 0) {
      console.log('ü§ñ AIÁÑ°ÁßªÂãïÂèØËµ∞ÔºåÊ∫ñÂÇôÊäïÈôç');
      return null;
    }

    // Ê™¢Êü•ÊòØÂê¶Ë¢´Â∞áËªçÔºåÂ¶ÇÊûúÊòØÂâá‰ΩøÁî®Á∑äÊÄ•Èò≤ÂÆà
    const isInCheck = this.chessGameService.isInCheck(gameState.board, PlayerColor.BLACK);

    if (isInCheck) {
      console.log('ü§ñ AIË¢´Â∞áËªçÔºÅÂÑ™ÂÖàËÄÉÊÖÆÈò≤ÂÆàÂãï‰Ωú...');
      const emergencyMove = this.findEmergencyDefenseMove(gameState, allMoves);
      if (emergencyMove) {
        console.log(`ü§ñ AIÁ∑äÊÄ•Èò≤ÂÆà: (${emergencyMove.from.x},${emergencyMove.from.y}) -> (${emergencyMove.to.x},${emergencyMove.to.y})`);
        return emergencyMove;
      }
    }

    // Ê™¢Êü•ÊòØÂê¶ÂèØ‰ª•‰ΩøÁî®ÈñãÂ±ÄÂ∫´
    const openingMove = this.tryOpeningBook(gameState);
    if (openingMove) {
      console.log(`ü§ñ AI‰ΩøÁî®ÈñãÂ±ÄÂ∫´: ${openingMove.name}`);
      return openingMove;
    }

    const searchDepth = isInCheck ? Math.min(2, this.MAX_DEPTH) : this.MAX_DEPTH;
    console.log(`ü§ñ AI${isInCheck ? 'Ë¢´Â∞áËªçÔºå' : ''}‰ΩøÁî®Ê∑±Â∫¶ ${searchDepth} ÈÄ≤Ë°åÊêúÁ¥¢`);

    const bestMove = this.findBestMoveWithTimeout(gameState, searchDepth, 20000); // 20ÁßíË∂ÖÊôÇ

    if (bestMove) {
      // Ê∑ªÂä†Èö®Ê©üÊÄßÂíåÂ§öÊ®£ÊÄßÈÅ∏Êìá
      const finalMove = this.addMoveVariety(gameState, bestMove, allMoves);

      console.log(
        `ü§ñ AIÊ±∫ÂÆöÁßªÂãï: (${finalMove.from.x},${finalMove.from.y}) -> (${finalMove.to.x},${finalMove.to.y}), Ë©ïÂàÜ: ${finalMove.score || 'varied'}`
      );
      return {
        from: finalMove.from,
        to: finalMove.to,
      };
    }

    console.warn('ü§ñ AIÁÑ°Ê≥ïÊâæÂà∞ÊúÄ‰Ω≥ÁßªÂãïÊàñË∂ÖÊôÇÔºåÈö®Ê©üÈÅ∏Êìá');
    // Â¶ÇÊûúÊâæ‰∏çÂà∞ÊúÄ‰Ω≥ÁßªÂãïÊàñË∂ÖÊôÇÔºåÈö®Ê©üÈÅ∏Êìá‰∏ÄÂÄã
    const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];
    return {
      from: randomMove.from,
      to: randomMove.to,
    };
  }

  private findBestMoveWithTimeout(
    gameState: GameState,
    depth: number,
    timeoutMs: number
  ): MoveEvaluation | null {
    const startTime = Date.now();
    let bestMove: MoveEvaluation | null = null;

    try {
      // ‰ΩøÁî®Promise.race‰æÜÂØ¶ÁèæË∂ÖÊôÇ
      return this.findBestMoveInternal(gameState, depth, startTime, timeoutMs);
    } catch (error) {
      console.warn('ü§ñ AIÊêúÁ¥¢Ë∂ÖÊôÇÊàñÂá∫ÈåØ:', error);
      return bestMove;
    }
  }

  private findBestMoveInternal(
    gameState: GameState,
    depth: number,
    startTime: number,
    timeoutMs: number
  ): MoveEvaluation | null {
    const moves = this.getAllPossibleMoves(gameState, gameState.currentPlayer);

    if (moves.length === 0) return null;

    let bestMove: MoveEvaluation | null = null;
    let bestScore = gameState.currentPlayer === PlayerColor.BLACK ? -Infinity : Infinity;

    for (const move of moves) {
      // Ê™¢Êü•Ë∂ÖÊôÇ
      if (Date.now() - startTime > timeoutMs) {
        console.log('ü§ñ AIÊêúÁ¥¢Ë∂ÖÊôÇÔºåËøîÂõûÁï∂ÂâçÊúÄ‰Ω≥ÁßªÂãï');
        break;
      }

      // Ê®°Êì¨ÁßªÂãï
      const newGameState = this.simulateMove(gameState, move);

      // ‰ΩøÁî®MinimaxÁÆóÊ≥ïË©ï‰º∞Ôºå‰πüÂÇ≥ÂÖ•Ë∂ÖÊôÇÂèÉÊï∏
      const score = this.minimaxWithTimeout(
        newGameState,
        depth - 1,
        -Infinity,
        Infinity,
        gameState.currentPlayer === PlayerColor.RED,
        startTime,
        timeoutMs
      );

      move.score = score;

      if (gameState.currentPlayer === PlayerColor.BLACK) {
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      } else {
        if (score < bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }
    }

    return bestMove;
  }

  private minimaxWithTimeout(
    gameState: GameState,
    depth: number,
    alpha: number,
    beta: number,
    maximizingPlayer: boolean,
    startTime: number,
    timeoutMs: number
  ): number {
    // Ê™¢Êü•Ë∂ÖÊôÇ
    if (Date.now() - startTime > timeoutMs) {
      return this.evaluateBoard(gameState);
    }

    if (depth === 0 || gameState.gameOver) {
      return this.evaluateBoard(gameState);
    }

    const moves = this.getAllPossibleMoves(gameState, gameState.currentPlayer);

    if (maximizingPlayer) {
      let maxEval = -Infinity;
      for (const move of moves) {
        // ÊØèÊ¨°ÈÅûÊ≠∏ÂâçÈÉΩÊ™¢Êü•Ë∂ÖÊôÇ
        if (Date.now() - startTime > timeoutMs) {
          break;
        }

        const newGameState = this.simulateMove(gameState, move);
        const evaluation = this.minimaxWithTimeout(
          newGameState,
          depth - 1,
          alpha,
          beta,
          false,
          startTime,
          timeoutMs
        );
        maxEval = Math.max(maxEval, evaluation);
        alpha = Math.max(alpha, evaluation);
        if (beta <= alpha) break; // Alpha-betaÂâ™Êûù
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for (const move of moves) {
        // ÊØèÊ¨°ÈÅûÊ≠∏ÂâçÈÉΩÊ™¢Êü•Ë∂ÖÊôÇ
        if (Date.now() - startTime > timeoutMs) {
          break;
        }

        const newGameState = this.simulateMove(gameState, move);
        const evaluation = this.minimaxWithTimeout(
          newGameState,
          depth - 1,
          alpha,
          beta,
          true,
          startTime,
          timeoutMs
        );
        minEval = Math.min(minEval, evaluation);
        beta = Math.min(beta, evaluation);
        if (beta <= alpha) break; // Alpha-betaÂâ™Êûù
      }
      return minEval;
    }
  }

  private findEmergencyDefenseMove(gameState: GameState, allMoves: MoveEvaluation[]): { from: Position; to: Position } | null {
    const board = gameState.board;

    // ÊâæÂà∞AIÁöÑÁéã
    let aiKing: ChessPiece | null = null;
    for (let y = 0; y < 10 && !aiKing; y++) {
      for (let x = 0; x < 9 && !aiKing; x++) {
        const piece = board[y][x];
        if (piece && piece.color === PlayerColor.BLACK && piece.type === PieceType.KING) {
          aiKing = piece;
        }
      }
    }

    if (!aiKing) return null;

    // 1. ÂòóË©¶ÁßªÂãïÁéãÂà∞ÂÆâÂÖ®‰ΩçÁΩÆ
    const kingMoves = allMoves.filter(move =>
      move.from.x === aiKing!.position.x && move.from.y === aiKing!.position.y
    );

    for (const move of kingMoves) {
      // Ê®°Êì¨ÁßªÂãïÂæåÊ™¢Êü•ÊòØÂê¶ÂÆâÂÖ®
      const newGameState = this.simulateMove(gameState, move);
      if (!this.chessGameService.isInCheck(newGameState.board, PlayerColor.BLACK)) {
        return { from: move.from, to: move.to };
      }
    }

    // 2. Â∞ãÊâæËÉΩÊîîÊà™Â®ÅËÑÖÁöÑÁßªÂãï
    const blockingMoves = this.findBlockingMoves(gameState, allMoves, aiKing);
    if (blockingMoves.length > 0) {
      // ÈÅ∏ÊìáÊúÄ‰Ω≥ÊîîÊà™ÁßªÂãï
      return { from: blockingMoves[0].from, to: blockingMoves[0].to };
    }

    // 3. ÂòóË©¶ÂêÉÊéâÂ®ÅËÑÖÊ£ãÂ≠ê
    const captureMoves = this.findCaptureThreatMoves(gameState, allMoves, aiKing);
    if (captureMoves.length > 0) {
      return { from: captureMoves[0].from, to: captureMoves[0].to };
    }

    return null;
  }

  private findBlockingMoves(gameState: GameState, allMoves: MoveEvaluation[], aiKing: ChessPiece): MoveEvaluation[] {
    const blockingMoves: MoveEvaluation[] = [];

    // ÊâæÂà∞ÊâÄÊúâÂ®ÅËÑÖÁéãÁöÑÊïµÊñπÊ£ãÂ≠ê
    const threats = this.findThreatsToKing(gameState.board, aiKing);

    for (const threat of threats) {
      // Â∞çÊØèÂÄãÂ®ÅËÑÖÔºåÂ∞ãÊâæËÉΩÂ§†ÊîîÊà™ÁöÑÁßªÂãï
      const interceptPositions = this.getInterceptPositions(threat.position, aiKing.position);

      for (const move of allMoves) {
        if (interceptPositions.some(pos => pos.x === move.to.x && pos.y === move.to.y)) {
          // Á¢∫Ë™çÈÄôÂÄãÁßªÂãïÁúüÁöÑËÉΩËß£Èô§Â∞áËªç
          const newGameState = this.simulateMove(gameState, move);
          if (!this.chessGameService.isInCheck(newGameState.board, PlayerColor.BLACK)) {
            blockingMoves.push(move);
          }
        }
      }
    }

    return blockingMoves;
  }

  private findCaptureThreatMoves(gameState: GameState, allMoves: MoveEvaluation[], aiKing: ChessPiece): MoveEvaluation[] {
    const captureMoves: MoveEvaluation[] = [];

    // ÊâæÂà∞ÊâÄÊúâÂ®ÅËÑÖÁéãÁöÑÊïµÊñπÊ£ãÂ≠ê
    const threats = this.findThreatsToKing(gameState.board, aiKing);

    for (const threat of threats) {
      for (const move of allMoves) {
        // Ê™¢Êü•ÊòØÂê¶ËÉΩÂêÉÊéâÂ®ÅËÑÖÊ£ãÂ≠ê
        if (move.to.x === threat.position.x && move.to.y === threat.position.y) {
          // Á¢∫Ë™çÂêÉÊéâÂæåËÉΩËß£Èô§Â∞áËªç
          const newGameState = this.simulateMove(gameState, move);
          if (!this.chessGameService.isInCheck(newGameState.board, PlayerColor.BLACK)) {
            captureMoves.push(move);
          }
        }
      }
    }

    return captureMoves;
  }

  private findThreatsToKing(board: (ChessPiece | null)[][], aiKing: ChessPiece): ChessPiece[] {
    const threats: ChessPiece[] = [];

    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 9; x++) {
        const piece = board[y][x];
        if (piece && piece.color === PlayerColor.RED) {
          const moves = this.chessGameService.getPossibleMovesForCheck(piece, board);
          if (moves.some(move => move.x === aiKing.position.x && move.y === aiKing.position.y)) {
            threats.push(piece);
          }
        }
      }
    }

    return threats;
  }

  private getInterceptPositions(threatPos: Position, kingPos: Position): Position[] {
    const positions: Position[] = [];

    // Ë®àÁÆóÂ®ÅËÑÖÊ£ãÂ≠êÂà∞Áéã‰πãÈñìÁöÑË∑ØÂæë
    const dx = kingPos.x - threatPos.x;
    const dy = kingPos.y - threatPos.y;

    // Âè™ËôïÁêÜÁõ¥Á∑öÂ®ÅËÑÖÔºàËªä„ÄÅÁÇÆÔºâÊàñÂ∞çËßíÁ∑öÂ®ÅËÑÖÔºàÂú®Ë±°Ê£ã‰∏≠ËºÉÂ∞ëË¶ãÔºâ
    if (dx === 0) {
      // ÂûÇÁõ¥Á∑ö
      const step = dy > 0 ? 1 : -1;
      for (let y = threatPos.y + step; y !== kingPos.y; y += step) {
        positions.push({ x: threatPos.x, y });
      }
    } else if (dy === 0) {
      // Ê∞¥Âπ≥Á∑ö
      const step = dx > 0 ? 1 : -1;
      for (let x = threatPos.x + step; x !== kingPos.x; x += step) {
        positions.push({ x, y: threatPos.y });
      }
    }

    return positions;
  }

  private tryOpeningBook(gameState: GameState): { from: Position; to: Position; name?: string } | null {
    const moveCount = gameState.moveHistory.length;

    // Âè™Âú®ÈñãÂ±ÄÂâç6Ê≠•‰ΩøÁî®ÈñãÂ±ÄÂ∫´
    if (moveCount >= 6) return null;

    // 30% Ê©üÁéá‰ΩøÁî®ÈñãÂ±ÄÂ∫´ÔºåÂ¢ûÂä†ËÆäÂåñ
    if (Math.random() > 0.3) return null;

    // Èö®Ê©üÈÅ∏Êìá‰∏ÄÂÄãÈñãÂ±ÄÈ°ûÂûã
    const openingType = this.OPENING_BOOK[Math.floor(Math.random() * this.OPENING_BOOK.length)];

    // ÂæûË©≤ÈñãÂ±ÄÈ°ûÂûã‰∏≠Èö®Ê©üÈÅ∏Êìá‰∏ÄÂÄãËÆäÂåñ
    const opening = openingType[Math.floor(Math.random() * openingType.length)];

    // Ê™¢Êü•ÈñãÂ±ÄÁßªÂãïÊòØÂê¶ÂêàÊ≥ï
    const piece = gameState.board[opening.from.y][opening.from.x];
    if (piece && piece.color === PlayerColor.BLACK) {
      const possibleMoves = this.chessGameService.getPossibleMoves(piece, gameState.board);
      const isValidMove = possibleMoves.some(move => move.x === opening.to.x && move.y === opening.to.y);

      if (isValidMove && !this.wouldMoveCauseSelfCheck(gameState, opening.from, opening.to)) {
        return { from: opening.from, to: opening.to, name: opening.name };
      }
    }

    return null;
  }

  private addMoveVariety(gameState: GameState, bestMove: MoveEvaluation, allMoves: MoveEvaluation[]): MoveEvaluation {
    // Ê†πÊìöAIÂÄãÊÄßÊ±∫ÂÆöÊòØÂê¶ÈÅ∏ÊìáËÆäÂåñ
    if (Math.random() > this.AI_PERSONALITY.CONSISTENCY) {

      // Ë©ï‰º∞ÊâÄÊúâÁßªÂãï‰∏¶ÊåâÂàÜÊï∏ÊéíÂ∫è
      for (const move of allMoves) {
        const newGameState = this.simulateMove(gameState, move);
        move.score = this.evaluateBoard(newGameState);
      }

      // ÊéíÂ∫èÂæóÂà∞ÊúÄ‰Ω≥ÁßªÂãïÂÄë
      allMoves.sort((a, b) => (b.score || 0) - (a.score || 0));

      // ÂæûÂâç3ÂÄãÊúÄ‰Ω≥ÁßªÂãï‰∏≠Èö®Ê©üÈÅ∏ÊìáÔºàÂ¶ÇÊûúÂàÜÊï∏Â∑ÆË∑ù‰∏çÂ§ßÔºâ
      const topMoves = allMoves.slice(0, 3);
      const bestScore = topMoves[0]?.score || 0;

      const viableMoves = topMoves.filter(move =>
        Math.abs((move.score || 0) - bestScore) <= bestScore * 0.1 // ÂàÜÊï∏Â∑ÆË∑ùÂú®10%ÂÖß
      );

      if (viableMoves.length > 1) {
        const selectedMove = viableMoves[Math.floor(Math.random() * viableMoves.length)];
        console.log(`ü§ñ AIÈÅ∏ÊìáËÆäÂåñËµ∞Ê≥ïÔºåÂæû${viableMoves.length}ÂÄãÁõ∏ËøëÈÅ∏È†Ö‰∏≠ÈÅ∏Êìá`);
        return selectedMove;
      }
    }

    // Âä†ÂÖ•ÂâµÈÄ†ÊÄßÁßªÂãïÁöÑÂèØËÉΩÊÄß
    if (Math.random() < this.AI_PERSONALITY.CREATIVE * 0.2) {
      const creativeMoves = this.findCreativeMoves(gameState, allMoves);
      if (creativeMoves.length > 0) {
        const creativeMove = creativeMoves[Math.floor(Math.random() * creativeMoves.length)];
        console.log('ü§ñ AIÂòóË©¶ÂâµÊÑèËµ∞Ê≥ï');
        return creativeMove;
      }
    }

    return bestMove;
  }

  private findCreativeMoves(gameState: GameState, allMoves: MoveEvaluation[]): MoveEvaluation[] {
    const creativeMoves: MoveEvaluation[] = [];

    for (const move of allMoves) {
      const piece = gameState.board[move.from.y][move.from.x];
      if (!piece) continue;

      // Ë≠òÂà•‰∏Ä‰∫õÂâµÊÑèÁßªÂãïÊ®°Âºè
      let isCreative = false;

      // 1. Ê£ãÂ≠êÊ∑±ÂÖ•ÊïµÈô£
      if (piece.color === PlayerColor.BLACK && move.to.y > 6) {
        isCreative = true;
      }

      // 2. ÊÑèÂ§ñÁöÑÊ£ãÂ≠êÁßªÂãïÔºàÂ¶ÇË±°„ÄÅÂ£´Âá∫ÂÆÆÊîªÊìäÔºâ
      if (piece.type === PieceType.ELEPHANT || piece.type === PieceType.ADVISOR) {
        const distanceFromHome = Math.abs(move.to.y - (piece.color === PlayerColor.BLACK ? 0 : 9));
        if (distanceFromHome > 3) {
          isCreative = true;
        }
      }

      // 3. Êç®Ê£ãÈÄ†Âã¢
      if (move.capturedPiece && this.PIECE_VALUES[piece.type] > this.PIECE_VALUES[move.capturedPiece.type] * 1.5) {
        isCreative = true;
      }

      if (isCreative) {
        creativeMoves.push(move);
      }
    }

    return creativeMoves;
  }

  private getAllPossibleMoves(gameState: GameState, color: PlayerColor): MoveEvaluation[] {
    const moves: MoveEvaluation[] = [];

    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 9; x++) {
        const piece = gameState.board[y][x];
        if (piece && piece.color === color) {
          const possibleMoves = this.chessGameService.getPossibleMoves(piece, gameState.board);

          for (const to of possibleMoves) {
            const capturedPiece = gameState.board[to.y][to.x];

            // Ê™¢Êü•ÁßªÂãïÂæåÊòØÂê¶ÊúÉËÆìËá™Â∑±Ë¢´Â∞áËªçÔºàËá™ÊÆ∫ÁßªÂãïÔºâ
            if (!this.wouldMoveCauseSelfCheck(gameState, piece.position, to)) {
              moves.push({
                from: piece.position,
                to,
                score: 0,
                capturedPiece: capturedPiece || undefined,
              });
            }
          }
        }
      }
    }

    return moves;
  }

  private wouldMoveCauseSelfCheck(gameState: GameState, from: Position, to: Position): boolean {
    const board = gameState.board;
    const piece = board[from.y][from.x];
    if (!piece) return true; // ÁÑ°ÊïàÁßªÂãï

    // Ëá®ÊôÇÂü∑Ë°åÁßªÂãï
    const originalTarget = board[to.y][to.x];
    const originalPos = piece.position;

    board[to.y][to.x] = piece;
    board[from.y][from.x] = null;
    piece.position = to;

    // Ê™¢Êü•ÊòØÂê¶Ë¢´Â∞áËªç
    const inCheck = this.chessGameService.isInCheck(board, piece.color);

    // ÈÇÑÂéüÁßªÂãï
    board[from.y][from.x] = piece;
    board[to.y][to.x] = originalTarget;
    piece.position = originalPos;

    return inCheck;
  }

  private simulateMove(gameState: GameState, move: MoveEvaluation): GameState {
    // Ê∑±Êã∑Ë≤ùÈÅäÊà≤ÁãÄÊÖã
    const newBoard = gameState.board.map((row) =>
      row.map((piece) => (piece ? { ...piece, position: { ...piece.position } } : null))
    );

    // Âü∑Ë°åÁßªÂãï
    const piece = newBoard[move.from.y][move.from.x];
    if (piece) {
      newBoard[move.to.y][move.to.x] = piece;
      newBoard[move.from.y][move.from.x] = null;
      piece.position = { ...move.to };
    }

    return {
      ...gameState,
      board: newBoard,
      currentPlayer:
        gameState.currentPlayer === PlayerColor.RED ? PlayerColor.BLACK : PlayerColor.RED,
    };
  }

  private evaluateBoard(gameState: GameState): number {
    let score = 0;

    // 1. Âü∫Êú¨Ê£ãÂ≠êÂÉπÂÄºË©ï‰º∞ÔºàÊúÄÈáçË¶ÅÔºâ
    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 9; x++) {
        const piece = gameState.board[y][x];
        if (piece) {
          let pieceScore = this.PIECE_VALUES[piece.type];

          // Á∞°ÂåñÁöÑ‰ΩçÁΩÆÁçéÂãµ
          pieceScore += this.getSimplePositionBonus(piece);

          // Ê†πÊìöÈ°èËâ≤Ë™øÊï¥ÂàÜÊï∏ (ÈªëÊñπAIÔºåÊâÄ‰ª•ÈªëÊñπÊ≠£ÂàÜÔºåÁ¥ÖÊñπË≤†ÂàÜ)
          if (piece.color === PlayerColor.BLACK) {
            score += pieceScore;
          } else {
            score -= pieceScore;
          }
        }
      }
    }

    // 2. Â∞áËªçÊ™¢Ê∏¨Ë©ïÂàÜÔºàÈ´òÂÑ™ÂÖàÁ¥öÔºâ
    if (this.chessGameService.isInCheck(gameState.board, PlayerColor.RED)) {
      score += 300; // Â∞áËªçÂ∞çÊñπÁçéÂãµ
    }
    if (this.chessGameService.isInCheck(gameState.board, PlayerColor.BLACK)) {
      score -= 300; // Ë¢´Â∞áËªçÊá≤ÁΩ∞
    }

    // 3. Á∞°ÂåñÁöÑÂÆâÂÖ®ÊÄßÊ™¢Êü•
    score += this.getBasicSafetyScore(gameState.board);

    return score;
  }

  private getSimplePositionBonus(piece: ChessPiece): number {
    const { x, y } = piece.position;
    let bonus = 0;

    // Âü∫Êú¨‰∏≠Â§ÆÊéßÂà∂ÁçéÂãµ
    const centerDistance = Math.abs(y - 4.5) + Math.abs(x - 4);
    bonus += Math.max(0, (9 - centerDistance) * 2);

    // ÂÖµÈÅéÊ≤≥ÁçéÂãµ
    if (piece.type === PieceType.SOLDIER) {
      const hasPassedRiver = (piece.color === PlayerColor.RED && y < 5) ||
                           (piece.color === PlayerColor.BLACK && y > 4);
      if (hasPassedRiver) {
        bonus += 30;
      }
    }

    return bonus;
  }

  private getBasicSafetyScore(board: (ChessPiece | null)[][]): number {
    let score = 0;

    // Âè™Ê™¢Êü•ÊúÄÈáçË¶ÅÁöÑÊ£ãÂ≠êÂÆâÂÖ®ÊÄß
    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 9; x++) {
        const piece = board[y][x];
        if (piece && piece.color === PlayerColor.BLACK) {
          const pieceValue = this.PIECE_VALUES[piece.type];

          // Âè™ÈóúÂøÉÈ´òÂÉπÂÄºÊ£ãÂ≠êÁöÑÂÆâÂÖ®
          if (pieceValue >= 400) {
            const isThreatened = this.isSimpleThreatened(x, y, piece, board);
            if (isThreatened) {
              score -= Math.min(100, pieceValue * 0.2); // ÈôêÂà∂Êá≤ÁΩ∞‰∏äÈôê
            }
          }
        }
      }
    }

    return score;
  }

  private isSimpleThreatened(x: number, y: number, piece: ChessPiece, board: (ChessPiece | null)[][]): boolean {
    // Á∞°ÂåñÁöÑÂ®ÅËÑÖÊ™¢Ê∏¨
    for (let r = 0; r < 10; r++) {
      for (let c = 0; c < 9; c++) {
        const enemy = board[r][c];
        if (enemy && enemy.color === PlayerColor.RED) {
          const enemyMoves = this.chessGameService.getPossibleMovesForCheck(enemy, board);
          if (enemyMoves.some(move => move.x === x && move.y === y)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  private getPositionBonus(piece: ChessPiece): number {
    const { x, y } = piece.position;
    let bonus = 0;

    // ‰∏≠Â§ÆÊéßÂà∂ÁçéÂãµ
    const centerDistance = Math.abs(y - 4.5) + Math.abs(x - 4);
    bonus += (9 - centerDistance) * 2;

    // ÁâπÊÆäÊ£ãÂ≠ê‰ΩçÁΩÆÁçéÂãµ
    switch (piece.type) {
      case PieceType.HORSE:
        // È¶¨Âú®‰∏≠Â§ÆÊõ¥ÊúâÂ®ÅÂäõ
        if (y >= 2 && y <= 7 && x >= 1 && x <= 7) {
          bonus += 30;
        }
        break;
      case PieceType.CANNON:
        // ÁÇÆÂú®ÂæåÊéíÂíå‰∏≠Â§ÆÂàóÊõ¥Â•Ω
        if (x === 4 || y === (piece.color === PlayerColor.RED ? 7 : 2)) {
          bonus += 20;
        }
        break;
      case PieceType.SOLDIER:
        // ÂÖµÈÅéÊ≤≥ÁçéÂãµ
        const hasPassedRiver =
          (piece.color === PlayerColor.RED && y < 5) ||
          (piece.color === PlayerColor.BLACK && y > 4);
        if (hasPassedRiver) {
          bonus += 50;
          // ÂÖµÂú®ÊïµÊñπÈô£Âú∞Êõ¥Ê∑±ÂÖ•Êõ¥Â•Ω
          const depth = piece.color === PlayerColor.RED ? 4 - y : y - 5;
          bonus += depth * 10;
        }
        break;
    }

    return bonus;
  }

  private getThreatScore(
    x: number,
    y: number,
    piece: ChessPiece,
    board: (ChessPiece | null)[][]
  ): number {
    let score = 0;
    const enemyColor = piece.color === PlayerColor.RED ? PlayerColor.BLACK : PlayerColor.RED;

    // Ê™¢Êü•ÊòØÂê¶ÂèóÂà∞ÊïµÊñπÊîªÊìä
    for (let r = 0; r < 10; r++) {
      for (let c = 0; c < 9; c++) {
        const enemyPiece = board[r][c];
        if (enemyPiece && enemyPiece.color === enemyColor) {
          const enemyMoves = this.chessGameService.getPossibleMoves(enemyPiece, board);
          if (enemyMoves.some((move) => move.x === x && move.y === y)) {
            // ÂèóÂà∞ÊîªÊìäÔºåÊ†πÊìöÊ£ãÂ≠êÂÉπÂÄºÊ∏õÂàÜ
            score -= this.PIECE_VALUES[piece.type] * 0.5;
            break;
          }
        }
      }
    }

    return score;
  }

  private getCenterControlScore(board: (ChessPiece | null)[][]): number {
    let score = 0;
    const centerCells = [
      { x: 3, y: 4 },
      { x: 4, y: 4 },
      { x: 5, y: 4 },
      { x: 3, y: 5 },
      { x: 4, y: 5 },
      { x: 5, y: 5 },
    ];

    for (const { x, y } of centerCells) {
      const piece = board[y][x];
      if (piece) {
        if (piece.color === PlayerColor.BLACK) {
          score += 15;
        } else {
          score -= 15;
        }
      }
    }

    return score;
  }

  private getCheckScore(board: (ChessPiece | null)[][]): number {
    let score = 0;

    // Ê™¢Êü•AIÊòØÂê¶Âú®Â∞áËªçÂ∞çÊâã
    if (this.chessGameService.isInCheck(board, PlayerColor.RED)) {
      score += 100; // Â∞áËªçÁçéÂãµ
    }

    // Ê™¢Êü•AIÁöÑÁéãÊòØÂê¶Ë¢´Â∞áËªç
    if (this.chessGameService.isInCheck(board, PlayerColor.BLACK)) {
      score -= 100; // Ë¢´Â∞áËªçÊá≤ÁΩ∞
    }

    return score;
  }

  private getDefenseScore(board: (ChessPiece | null)[][]): number {
    let score = 0;

    // 1. Ê™¢Êü•AIÈáçË¶ÅÊ£ãÂ≠êÊòØÂê¶ÂèóÂà∞‰øùË≠∑
    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 9; x++) {
        const piece = board[y][x];
        if (piece && piece.color === PlayerColor.BLACK) {
          // ÈáçË¶ÅÊ£ãÂ≠êÈúÄË¶Å‰øùË≠∑
          const pieceValue = this.PIECE_VALUES[piece.type];
          if (pieceValue >= 400) { // È¶¨„ÄÅËªä„ÄÅÁÇÆ„ÄÅÂ∞á
            const isProtected = this.isPieceProtected(x, y, piece, board);
            const isThreatenend = this.isPieceThreatened(x, y, piece, board);

            if (isThreatenend && !isProtected) {
              score -= pieceValue * 0.3; // ÈáçË¶ÅÊ£ãÂ≠êË¢´Â®ÅËÑÖ‰∏îÁÑ°‰øùË≠∑
            } else if (isProtected && isThreatenend) {
              score += 50; // Ë¢´Â®ÅËÑÖ‰ΩÜÊúâ‰øùË≠∑
            }
          }
        }
      }
    }

    // 2. Ê™¢Êü•ÊòØÂê¶ËÉΩÊîîÊà™ÊïµÊñπÂ®ÅËÑÖ
    score += this.getInterceptionScore(board);

    // 3. Ê™¢Êü•ÁéãÁöÑÂÆâÂÖ®ÊÄß
    score += this.getKingSafetyScore(board);

    return score;
  }

  private isPieceProtected(x: number, y: number, piece: ChessPiece, board: (ChessPiece | null)[][]): boolean {
    // Ê™¢Êü•ÊòØÂê¶ÊúâÂ∑±ÊñπÊ£ãÂ≠êËÉΩ‰øùË≠∑ÈÄôÂÄã‰ΩçÁΩÆ
    for (let r = 0; r < 10; r++) {
      for (let c = 0; c < 9; c++) {
        const defender = board[r][c];
        if (defender && defender.color === piece.color && defender !== piece) {
          const defenderMoves = this.chessGameService.getPossibleMovesForCheck(defender, board);
          if (defenderMoves.some(move => move.x === x && move.y === y)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  private isPieceThreatened(x: number, y: number, piece: ChessPiece, board: (ChessPiece | null)[][]): boolean {
    const enemyColor = piece.color === PlayerColor.RED ? PlayerColor.BLACK : PlayerColor.RED;

    for (let r = 0; r < 10; r++) {
      for (let c = 0; c < 9; c++) {
        const enemy = board[r][c];
        if (enemy && enemy.color === enemyColor) {
          const enemyMoves = this.chessGameService.getPossibleMovesForCheck(enemy, board);
          if (enemyMoves.some(move => move.x === x && move.y === y)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  private getInterceptionScore(board: (ChessPiece | null)[][]): number {
    let score = 0;

    // Ê™¢Êü•ÊïµÊñπÊòØÂê¶ÊúâÂº∑ÂäõÊîªÊìäÁ∑öË∑ØÔºåAIÊòØÂê¶ËÉΩÊîîÊà™
    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 9; x++) {
        const enemy = board[y][x];
        if (enemy && enemy.color === PlayerColor.RED) {
          const enemyMoves = this.chessGameService.getPossibleMovesForCheck(enemy, board);

          // Ê™¢Êü•ÊïµÊñπÊòØÂê¶Â®ÅËÑÖAIÁöÑÈ´òÂÉπÂÄºÊ£ãÂ≠ê
          for (const move of enemyMoves) {
            const target = board[move.y][move.x];
            if (target && target.color === PlayerColor.BLACK && this.PIECE_VALUES[target.type] >= 400) {
              // ÊïµÊñπÂ®ÅËÑÖAIÈáçË¶ÅÊ£ãÂ≠êÔºåÊ™¢Êü•AIÊòØÂê¶ËÉΩÊîîÊà™ÊàñÂèçÊìä
              const canCounter = this.canCounterThreat(x, y, move.x, move.y, board);
              if (canCounter) {
                score += 80; // ËÉΩÂèçÊìäÁöÑÁçéÂãµ
              }
            }
          }
        }
      }
    }

    return score;
  }

  private canCounterThreat(enemyX: number, enemyY: number, targetX: number, targetY: number, board: (ChessPiece | null)[][]): boolean {
    // Ê™¢Êü•AIÊòØÂê¶ËÉΩÊîªÊìäÂ®ÅËÑÖÊ∫êÊàñ‰øùË≠∑ÁõÆÊ®ô
    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 9; x++) {
        const aiPiece = board[y][x];
        if (aiPiece && aiPiece.color === PlayerColor.BLACK) {
          const aiMoves = this.chessGameService.getPossibleMovesForCheck(aiPiece, board);

          // ÂèØ‰ª•ÊîªÊìäÊïµÊñπÂ®ÅËÑÖÊ∫ê
          if (aiMoves.some(move => move.x === enemyX && move.y === enemyY)) {
            return true;
          }

          // ÂèØ‰ª•‰øùË≠∑Ë¢´Â®ÅËÑÖÁöÑÁõÆÊ®ô
          if (aiMoves.some(move => move.x === targetX && move.y === targetY)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  private getKingSafetyScore(board: (ChessPiece | null)[][]): number {
    let score = 0;

    // ÊâæÂà∞AIÁöÑÁéã
    let aiKing: ChessPiece | null = null;
    for (let y = 0; y < 10 && !aiKing; y++) {
      for (let x = 0; x < 9 && !aiKing; x++) {
        const piece = board[y][x];
        if (piece && piece.color === PlayerColor.BLACK && piece.type === PieceType.KING) {
          aiKing = piece;
        }
      }
    }

    if (aiKing) {
      const { x, y } = aiKing.position;

      // Ê™¢Êü•ÁéãÂë®ÂúçÊòØÂê¶ÊúâÂ∑±ÊñπÊ£ãÂ≠ê‰øùË≠∑
      const surroundingPositions = [
        { x: x-1, y: y-1 }, { x, y: y-1 }, { x: x+1, y: y-1 },
        { x: x-1, y }, { x: x+1, y },
        { x: x-1, y: y+1 }, { x, y: y+1 }, { x: x+1, y: y+1 }
      ];

      let protectors = 0;
      for (const pos of surroundingPositions) {
        if (pos.x >= 3 && pos.x <= 5 && pos.y >= 0 && pos.y <= 2) { // Âú®ÂÆÆÂÖß
          const piece = board[pos.y]?.[pos.x];
          if (piece && piece.color === PlayerColor.BLACK) {
            protectors++;
          }
        }
      }

      // ÁéãÂë®ÂúçÊúâ‰øùË≠∑Ê£ãÂ≠êÊòØÂ•ΩÁöÑ
      score += protectors * 15;

      // Ê™¢Êü•ÁéãÊòØÂê¶Ë¢´Â§öÂÄãÊïµÊñπÊ£ãÂ≠êÂ®ÅËÑÖ
      let threatCount = 0;
      for (let r = 0; r < 10; r++) {
        for (let c = 0; c < 9; c++) {
          const enemy = board[r][c];
          if (enemy && enemy.color === PlayerColor.RED) {
            const enemyMoves = this.chessGameService.getPossibleMovesForCheck(enemy, board);
            if (enemyMoves.some(move => move.x === x && move.y === y)) {
              threatCount++;
            }
          }
        }
      }

      if (threatCount > 1) {
        score -= 200; // Ë¢´Â§öÈáçÂ®ÅËÑÖÂæàÂç±Èö™
      } else if (threatCount === 1) {
        score -= 100; // Ë¢´ÂñÆ‰∏ÄÂ®ÅËÑÖ
      }
    }

    return score;
  }

  // Áç≤ÂèñAIÊÄùËÄÉÁöÑÊèèËø∞ÊñáÂ≠ó
  getThinkingDescription(gameState: GameState): string {
    const threats = this.analyzeThreats(gameState);
    const opportunities = this.analyzeOpportunities(gameState);

    const descriptions = [
      'Ê≠£Âú®ÂàÜÊûêÊ£ãÂ±ÄÂΩ¢Âã¢...',
      'Ë®àÁÆóÊúÄ‰Ω≥ÁßªÂãïË∑ØÁ∑ö...',
      'Ë©ï‰º∞ÊîªÈò≤Âπ≥Ë°°...',
      'Â∞ãÊâæÊà∞Ë°ìÊ©üÊúÉ...',
    ];

    if (threats.length > 0) {
      descriptions.push('ÁôºÁèæÂ®ÅËÑÖÔºåÊ≠£Âú®Âà∂ÂÆöÈò≤ÂÆàÁ≠ñÁï•...');
    }

    if (opportunities.length > 0) {
      descriptions.push('ÁôºÁèæÊîªÊìäÊ©üÊúÉÔºåÊ≠£Âú®Ë®àÁÆó...');
    }

    return descriptions[Math.floor(Math.random() * descriptions.length)];
  }

  private analyzeThreats(gameState: GameState): Position[] {
    // Á∞°ÂåñÁöÑÂ®ÅËÑÖÂàÜÊûê
    const threats: Position[] = [];
    const aiColor = PlayerColor.BLACK;
    const opponentColor = PlayerColor.RED;

    // Ê™¢Êü•AIÁöÑÂ∞áÊòØÂê¶Ë¢´Â®ÅËÑÖ
    if (this.chessGameService.isInCheck(gameState.board, aiColor)) {
      // ÊâæÂà∞Â∞áÁöÑ‰ΩçÁΩÆ
      for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 9; x++) {
          const piece = gameState.board[y][x];
          if (piece && piece.type === PieceType.KING && piece.color === aiColor) {
            threats.push({ x, y });
            break;
          }
        }
      }
    }

    return threats;
  }

  private analyzeOpportunities(gameState: GameState): Position[] {
    // Á∞°ÂåñÁöÑÊ©üÊúÉÂàÜÊûê
    const opportunities: Position[] = [];
    const aiColor = PlayerColor.BLACK;

    // Ê™¢Êü•ÊòØÂê¶ËÉΩÂ∞áËªçÂ∞çÊâã
    if (this.chessGameService.isInCheck(gameState.board, PlayerColor.RED)) {
      opportunities.push({ x: 4, y: 9 }); // ÂÅáË®≠Â∞çÊâãÂ∞áÁöÑ‰ΩçÁΩÆ
    }

    return opportunities;
  }

  // Â≠∏ÁøíÁ≥ªÁµ±Áõ∏ÈóúÊñπÊ≥ï
  private loadGameMemory(): void {
    try {
      // Ê™¢Êü•ÊòØÂê¶Âú®ÁÄèË¶ΩÂô®Áí∞Â¢É
      if (typeof localStorage !== 'undefined') {
        const stored = localStorage.getItem('chinese-chess-ai-memory');
        if (stored) {
          this.gameMemory = { ...this.gameMemory, ...JSON.parse(stored) };
          console.log(`ü§ñ AIËºâÂÖ•‰∫Ü${this.gameMemory.gameCount}Â±ÄÈÅäÊà≤ÁöÑÂ≠∏ÁøíÊï∏Êìö`);
        }
      }
    } catch (error) {
      console.warn('ü§ñ AIÂ≠∏ÁøíÊï∏ÊìöËºâÂÖ•Â§±Êïó:', error);
    }
  }

  private saveGameMemory(): void {
    try {
      // Ê™¢Êü•ÊòØÂê¶Âú®ÁÄèË¶ΩÂô®Áí∞Â¢É
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem('chinese-chess-ai-memory', JSON.stringify(this.gameMemory));
      }
    } catch (error) {
      console.warn('ü§ñ AIÂ≠∏ÁøíÊï∏Êìö‰øùÂ≠òÂ§±Êïó:', error);
    }
  }

  // ÂÖ¨ÈñãÊñπÊ≥ïÔºöÂ≠∏ÁøíÁé©ÂÆ∂ÁßªÂãï
  learnFromPlayerMove(from: Position, to: Position, gameState: GameState): void {
    if (this.gameMemory.playerMoves.length > 1000) {
      // ÈôêÂà∂Ë®òÊÜ∂ÂÆπÈáèÔºåÁßªÈô§ÊúÄËàäÁöÑË®òÈåÑ
      this.gameMemory.playerMoves.shift();
    }

    // Ë©ï‰º∞Áé©ÂÆ∂ÁßªÂãïÁöÑÁâπÊÄß
    const moveEvaluation = this.evaluatePlayerMoveStyle(from, to, gameState);

    this.gameMemory.playerMoves.push({
      from,
      to,
      evaluation: moveEvaluation.score
    });

    // Êõ¥Êñ∞Áé©ÂÆ∂ÂÅèÂ•ΩÁµ±Ë®à
    this.gameMemory.playerPreferences.aggressive += moveEvaluation.aggressive * 0.1;
    this.gameMemory.playerPreferences.defensive += moveEvaluation.defensive * 0.1;
    this.gameMemory.playerPreferences.positional += moveEvaluation.positional * 0.1;

    // ‰øùÊåÅÂÅèÂ•ΩÂÄºÂú®ÂêàÁêÜÁØÑÂúçÂÖß
    Object.keys(this.gameMemory.playerPreferences).forEach(key => {
      const k = key as keyof typeof this.gameMemory.playerPreferences;
      this.gameMemory.playerPreferences[k] = Math.max(0.1, Math.min(0.9, this.gameMemory.playerPreferences[k]));
    });

    this.saveGameMemory();
  }

  private evaluatePlayerMoveStyle(from: Position, to: Position, gameState: GameState): {
    score: number;
    aggressive: number;
    defensive: number;
    positional: number;
  } {
    const piece = gameState.board[from.y][from.x];
    let aggressive = 0;
    let defensive = 0;
    let positional = 0;

    if (!piece) return { score: 0, aggressive: 0, defensive: 0, positional: 0 };

    // ÂàÜÊûêÁßªÂãïÁâπÊÄß
    const capturedPiece = gameState.board[to.y][to.x];

    // ÊîªÊìäÊÄßÁâπÂæµ
    if (capturedPiece) {
      aggressive += 0.8; // ÂêÉÂ≠ê
    }
    if (to.y > 5) { // Ê∑±ÂÖ•ÊïµÈô£
      aggressive += 0.6;
    }

    // Èò≤ÂÆàÊÄßÁâπÂæµ
    if (to.y < 3) { // ‰øùÊåÅÂú®Â∑±ÊñπÈô£Âú∞
      defensive += 0.7;
    }
    if (piece.type === PieceType.ADVISOR || piece.type === PieceType.ELEPHANT) {
      defensive += 0.5; // ‰ΩøÁî®Èò≤ÂÆàÊ£ãÂ≠ê
    }

    // ‰ΩçÁΩÆÊÄßÁâπÂæµ
    const centerDistance = Math.abs(to.x - 4) + Math.abs(to.y - 4.5);
    if (centerDistance < 3) {
      positional += 0.8; // ÊéßÂà∂‰∏≠Â§Æ
    }

    const score = aggressive * 0.4 + defensive * 0.3 + positional * 0.3;

    return { score, aggressive, defensive, positional };
  }

  // ÂÖ¨ÈñãÊñπÊ≥ïÔºöÈÅäÊà≤ÁµêÊùüÂæåÂ≠∏Áøí
  learnFromGameEnd(playerWon: boolean): void {
    this.gameMemory.gameCount++;

    if (playerWon) {
      // Áé©ÂÆ∂Áç≤ÂãùÔºåAIÈúÄË¶ÅË™øÊï¥Á≠ñÁï•
      console.log('ü§ñ AIÂæûÂ§±Êïó‰∏≠Â≠∏Áøí...');
    } else {
      console.log('ü§ñ AIË®òÈåÑÂãùÂà©Á∂ìÈ©ó...');
    }

    // Ê†πÊìöÈÅäÊà≤Á∂ìÈ©óÂæÆË™øAIÂÄãÊÄß
    this.adjustAIPersonality();
    this.saveGameMemory();
  }

  private adjustAIPersonality(): void {
    // Ê†πÊìöÁé©ÂÆ∂ÂÅèÂ•ΩË™øÊï¥AIÁ≠ñÁï•
    const playerStyle = this.gameMemory.playerPreferences;

    // Â¶ÇÊûúÁé©ÂÆ∂ÂÅèÊîªÊìäÔºåAIËÆäÂæóÊõ¥Ë¨πÊÖé
    if (playerStyle.aggressive > 0.6) {
      this.AI_PERSONALITY.CAUTIOUS = Math.min(0.8, this.AI_PERSONALITY.CAUTIOUS + 0.1);
    }

    // Â¶ÇÊûúÁé©ÂÆ∂ÂÅèÈò≤ÂÆàÔºåAIËÆäÂæóÊõ¥ÊîªÊìä
    if (playerStyle.defensive > 0.6) {
      this.AI_PERSONALITY.AGGRESSIVE = Math.min(0.9, this.AI_PERSONALITY.AGGRESSIVE + 0.1);
    }

    console.log('ü§ñ AIÊ†πÊìöÁé©ÂÆ∂È¢®Ê†ºË™øÊï¥‰∫ÜÁ≠ñÁï•', {
      player: playerStyle,
      aiPersonality: this.AI_PERSONALITY
    });
  }
}
